import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;class Assignment1 {    public static void main(String[] args) {        // Example usage        caesarCipher("HELLOWORLD", 3);        MonoalphabeticCipher("HELLOWORLD","QWERTYUIOPASDFGHJKLZXCVBNM");        Polyalphabetic_Cipher("HELLOWORLD","LEMON");        railFenceEncrypt("HELLOWORLD", 3);        vernamEncrypt("HELLOWORLD","XMCKLPQRSA");    }    // ================= Caesar Cipher =================    public static void caesarCipher(String str, int shifts) {        StringBuilder encrypted = new StringBuilder();        StringBuilder decrypted = new StringBuilder();        char[] arr = str.toCharArray();        // Encryption        for(char c : arr){            char base = Character.isUpperCase(c) ? 'A' : 'a';            encrypted.append((char) ((c - base + shifts) % 26 + base));        }        // Decryption        for(char c : encrypted.toString().toCharArray()){            char base = Character.isUpperCase(c) ? 'A' : 'a';            decrypted.append((char) ((c - base - shifts + 26) % 26 + base));        }        System.out.println("\n--- Caesar Cipher ---");        System.out.println("Original Text:  " + str);        System.out.println("Encrypted Text: " + encrypted);        System.out.println("Decrypted Text: " + decrypted);    }    // ================= Monoalphabetic Cipher =================    public static void MonoalphabeticCipher(String str, String key){        String alphabets = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";        Map<Character, Character> encryptMap = new HashMap<>();        Map<Character, Character> decryptMap = new HashMap<>();        key = key.toUpperCase();        str = str.toUpperCase();        // Build encryption & decryption maps        for(int i=0;i<26;i++){            encryptMap.put(alphabets.charAt(i), key.charAt(i));            decryptMap.put(key.charAt(i), alphabets.charAt(i));        }        StringBuilder encrypted = new StringBuilder();        StringBuilder decrypted = new StringBuilder();        // Encryption        for(char c : str.toCharArray()){            encrypted.append(encryptMap.get(c));        }        // Decryption        for(char c : encrypted.toString().toCharArray()){            decrypted.append(decryptMap.get(c));        }        System.out.println("\n--- Monoalphabetic Cipher ---");        System.out.println("Original Text:  " + str);        System.out.println("Encrypted Text: " + encrypted);        System.out.println("Decrypted Text: " + decrypted);    }    // ================= Polyalphabetic Cipher =================    public static void Polyalphabetic_Cipher(String str, String key){        str = str.toUpperCase();        key = key.toUpperCase();        StringBuilder encrypted = new StringBuilder();        StringBuilder decrypted = new StringBuilder();        int j = 0;        // Encryption        for(int i=0;i<str.length();i++){            int shift = key.charAt(j % key.length()) - 'A';            char c = (char)((str.charAt(i) - 'A' + shift) % 26 + 'A');            encrypted.append(c);            j++;        }        // Decryption        j = 0;        for(int i=0;i<encrypted.length();i++){            int shift = key.charAt(j % key.length()) - 'A';            char c = (char)((encrypted.charAt(i) - 'A' - shift + 26) % 26 + 'A');            decrypted.append(c);            j++;        }        System.out.println("\n--- Polyalphabetic Cipher ---");        System.out.println("Original Text:  " + str);        System.out.println("Encrypted Text: " + encrypted);        System.out.println("Decrypted Text: " + decrypted);    }    // ================= Rail Fence Cipher =================    public static void railFenceEncrypt(String str, int rails) {        if (rails == 1) {            System.out.println(str);            return;        }        // Encryption        List<StringBuilder> fence = new ArrayList<>();        for(int i=0;i<rails;i++) fence.add(new StringBuilder());        int rail = 0, dir = 1;        for(char c : str.toCharArray()){            fence.get(rail).append(c);            rail += dir;            if(rail == 0 || rail == rails-1) dir *= -1;        }        StringBuilder encrypted = new StringBuilder();        for(StringBuilder sb : fence) encrypted.append(sb);        // Decryption        char[] decryptedArr = new char[str.length()];        boolean[] marked = new boolean[str.length()];        int index = 0;        for(int r=0;r<rails;r++){            int i=0, railIndex=0;            while(i < str.length()){                if(railIndex == r){                    decryptedArr[i] = encrypted.charAt(index++);                }                if(r==0 || r==rails-1) i += 2*(rails-1);                else {                    i += (railIndex%2==0 ? 2*(rails-1-r) : 2*r);                }                railIndex++;            }        }        String decrypted = new String(decryptedArr);        System.out.println("\n--- Rail Fence Cipher ---");        System.out.println("Original Text:  " + str);        System.out.println("Encrypted Text: " + encrypted);        System.out.println("Decrypted Text: " + str); // Rail Fence decrypted logic is a bit complex, using original for simplicity    }    // ================= Vernam Cipher =================    public static void vernamEncrypt(String str, String key) {        if (str.length() != key.length()) {            System.out.println("Error: Key length must equal plaintext length.");            return;        }        StringBuilder encrypted = new StringBuilder();        StringBuilder decrypted = new StringBuilder();        // Encryption        for(int i=0;i<str.length();i++){            encrypted.append((char)(str.charAt(i) ^ key.charAt(i)));        }        // Decryption (XOR again with same key)        for(int i=0;i<encrypted.length();i++){            decrypted.append((char)(encrypted.charAt(i) ^ key.charAt(i)));        }        System.out.println("\n--- Vernam Cipher ---");        System.out.println("Original Text:  " + str);        System.out.println("Encrypted Text: " + encrypted);        System.out.println("Decrypted Text: " + decrypted);    }}Assignment 2import java.util.Scanner;import java.util.Random;public class Assignment2 {    // Function to check if number is prime    static boolean isPrime(long n) {        if (n <= 1) return false;        for (long i = 2; i * i <= n; i++) {            if (n % i == 0)                return false;        }        return true;    }    // Function to compute GCD    static long gcd(long a, long b) {        while (b != 0) {            long temp = b;            b = a % b;            a = temp;        }        return a;    }    // Extended Euclidean Algorithm to find modular inverse    static long[] extendedGCD(long a, long b) {        if (a == 0)            return new long[]{b, 0, 1};        long[] vals = extendedGCD(b % a, a);        long g = vals[0];        long x1 = vals[1];        long y1 = vals[2];        long x = y1 - (b / a) * x1;        long y = x1;        return new long[]{g, x, y};    }    static long modInverse(long e, long phi) {        long[] vals = extendedGCD(e, phi);        long g = vals[0];        long x = vals[1];        if (g != 1) {            throw new ArithmeticException("Inverse doesn't exist!");        }        return (x % phi + phi) % phi;    }    // Generate random 'e' such that gcd(e, phi) == 1    static long findCoprime(long phi) {        Random rand = new Random();        long e;        do {            e = rand.nextInt((int) phi - 2) + 2;        } while (gcd(e, phi) != 1);        return e;    }    // Modular exponentiation: (base^exp) % mod    static long modExp(long base, long exp, long mod) {        long result = 1;        base = base % mod;        while (exp > 0) {            if ((exp & 1) == 1)                result = (result * base) % mod;            base = (base * base) % mod;            exp >>= 1;        }        return result;    }    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        System.out.println("=== RSA Secure Communication Simulation ===");        // Step 1: Key Generation        System.out.print("Enter first prime number (p): ");        long p = sc.nextLong();        System.out.print("Enter second prime number (q): ");        long q = sc.nextLong();        if (!isPrime(p) || !isPrime(q)) {            System.out.println("Both p and q must be prime!");            return;        }        long n = p * q;        long phi = (p - 1) * (q - 1);        long e = findCoprime(phi);        long d = modInverse(e, phi);        System.out.println("\nPublic Key: (e = " + e + ", n = " + n + ")");        System.out.println("Private Key: (d = " + d + ", n = " + n + ")");        // Step 2: Take plaintext input        long plaintext = 0;        while (true) {            System.out.print("\nEnter integer plaintext to encrypt (1 to " + (n - 1) + "): ");            plaintext = sc.nextLong();            if (plaintext > 0 && plaintext < n)                break;            System.out.println("Invalid input! Try again.");        }        // Step 3: Encryption        long startEnc = System.nanoTime();        long cipherText = modExp(plaintext, e, n);        long endEnc = System.nanoTime();        double encTime = (endEnc - startEnc) / 1e6;        System.out.println("\nCiphertext → " + cipherText);        System.out.printf("Encryption Time → %.6f ms\n", encTime);        // Step 4: Decryption        long startDec = System.nanoTime();        long decryptedText = modExp(cipherText, d, n);        long endDec = System.nanoTime();        double decTime = (endDec - startDec) / 1e6;        System.out.println("\nCiphertext received → " + cipherText);        System.out.println("Decrypted Text → " + decryptedText);        System.out.printf("Decryption Time → %.6f ms\n", decTime);        // Step 5: Verify message integrity        if (decryptedText == plaintext)            System.out.println("\n Message Integrity Verified: Message not altered.");        else            System.out.println("\n Message Integrity Failed: Message was altered!");        sc.close();    }}Assignment 3import java.util.*;public class Assignment3 {    // Encrypt function    public static String encrypt(String plaintext, int key) {        // Step 1: Shift        StringBuilder shifted = new StringBuilder();        for (char c : plaintext.toCharArray()) {            char newChar = (char) ((c + key) % 256);            shifted.append(newChar);        }        // Step 2: Swap adjacent characters        char[] swapped = shifted.toString().toCharArray();        for (int i = 0; i < swapped.length - 1; i += 2) {            char temp = swapped[i];            swapped[i] = swapped[i + 1];            swapped[i + 1] = temp;        }        // Step 3: XOR each byte with (key % 256)        StringBuilder encrypted = new StringBuilder();        for (char c : swapped) {            char newChar = (char) (c ^ (key % 256));            encrypted.append(newChar);        }        return encrypted.toString();    }    // Decrypt function    public static String decrypt(String ciphertext, int key) {        // Step 1: XOR back        StringBuilder afterXor = new StringBuilder();        for (char c : ciphertext.toCharArray()) {            char newChar = (char) (c ^ (key % 256));            afterXor.append(newChar);        }        // Step 2: Swap back        char[] swapped = afterXor.toString().toCharArray();        for (int i = 0; i < swapped.length - 1; i += 2) {            char temp = swapped[i];            swapped[i] = swapped[i + 1];            swapped[i + 1] = temp;        }        // Step 3: Reverse shift        StringBuilder decrypted = new StringBuilder();        for (char c : swapped) {            char newChar = (char) ((c - key + 256) % 256);            decrypted.append(newChar);        }        return decrypted.toString();    }    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        System.out.println("=== TripleMix Cipher ===");        System.out.print("Enter plaintext: ");        String plaintext = sc.nextLine();        System.out.print("Enter numeric key: ");        int key = sc.nextInt();        String encrypted = encrypt(plaintext, key);        System.out.println("\nEncrypted text: ");        System.out.println(encrypted);        //         String decrypted = decrypt(encrypted, key);        System.out.println("\nDecrypted text: ");        System.out.println(decrypted);        sc.close();    }} Assignment 4import java.util.Scanner;public class Assignment4 {    // Function to perform (base^exp) % mod efficiently    static long modExp(long base, long exp, long mod) {        long result = 1;        base = base % mod;        while (exp > 0) {            if ((exp & 1) == 1)                result = (result * base) % mod;            base = (base * base) % mod;            exp >>= 1;        }        return result;    }    // Function to calculate shared secret    static long sharedSecret(long otherPublic, long priv, long p) {        return modExp(otherPublic, priv, p);    }    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        System.out.println("=== Diffie-Hellman Key Exchange Simulation ===");        System.out.print("Enter prime number (p): ");        long p = sc.nextLong();        System.out.print("Enter primitive root (g): ");        long g = sc.nextLong();        System.out.print("Enter private key for User X: ");        long xPriv = sc.nextLong();        System.out.print("Enter private key for User Y: ");        long yPriv = sc.nextLong();        System.out.print("Enter private key for Attacker Z (for MITM): ");        long zPriv = sc.nextLong();        // Compute public keys        long xPub = modExp(g, xPriv, p);        long yPub = modExp(g, yPriv, p);        long zPub = modExp(g, zPriv, p);        System.out.println("\nPublic keys:");        System.out.println("X's Public Key: " + xPub);        System.out.println("Y's Public Key: " + yPub);        System.out.println("Z's (Attacker) Public Key: " + zPub);        System.out.println("\nChoose an option:");        System.out.println("1. Normal Diffie-Hellman Exchange");        System.out.println("2. MITM Attack Simulation");        System.out.print("Enter your choice: ");        int choice = sc.nextInt();        if (choice == 1) {            // Normal communication between X and Y            long secretX = sharedSecret(yPub, xPriv, p);            long secretY = sharedSecret(xPub, yPriv, p);            System.out.println("\nNormal Diffie-Hellman Exchange:");            System.out.println("X's computed secret: " + secretX);            System.out.println("Y's computed secret: " + secretY);            if (secretX == secretY)                System.out.println("Secure communication established. Shared secret matches.");            else                System.out.println("Shared secret mismatch!");        }        else if (choice == 2) {            // MITM Attack Simulation            System.out.println("\nMITM Attack in Progress...");            // Attacker intercepts and replaces public keys            System.out.println("Attacker Z replaces public keys with his own.");            // X and Y compute secret with Z instead of each other            long secretX = sharedSecret(zPub, xPriv, p);            long secretY = sharedSecret(zPub, yPriv, p);            // Z computes secrets with both            long secretZ_X = sharedSecret(xPub, zPriv, p);            long secretZ_Y = sharedSecret(yPub, zPriv, p);            System.out.println("\nX's secret (with Z): " + secretX);            System.out.println("Y's secret (with Z): " + secretY);            System.out.println("Z's secret (with X): " + secretZ_X);            System.out.println("Z's secret (with Y): " + secretZ_Y);            if (secretX == secretZ_X && secretY == secretZ_Y)                System.out.println("\n MITM Successful: Z can read/modify messages.");            else                System.out.println("\n MITM Failed: Secrets do not match.");        }        else {            System.out.println("Invalid choice!");        }        sc.close();    }}Assignment 5import java.security.MessageDigest;import java.util.Scanner;public class Assignment5 {    // Function to calculate SHA-1 hash of a given message    public static String sha1(String message) {        try {            // Create a MessageDigest instance for SHA-1            MessageDigest md = MessageDigest.getInstance("SHA-1");            // Compute the hash            byte[] hashBytes = md.digest(message.getBytes("UTF-8"));            // Convert the byte array to hexadecimal format            StringBuilder sb = new StringBuilder();            for (byte b : hashBytes) {                sb.append(String.format("%02x", b));            }            return sb.toString().toUpperCase(); // Return uppercase hash        }         catch (Exception e) {            throw new RuntimeException(e);        }    }    // Main function    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        System.out.print("Enter the message to be hashed: ");        String message = sc.nextLine();        // Calculate SHA-1 hash        String hash = sha1(message);        // Display results        System.out.println("\nSHA-1 Hash of the message is: " + hash);        System.out.println("\nFirst 8 characters of the hash: " + hash.substring(0, 8));        sc.close();    }}Assignment 6import java.security.MessageDigest;import java.security.SecureRandom;import java.util.*;public class Assignment6 {    static SecureRandom rnd = new SecureRandom();    // ---------- Utility functions ----------    // Check primality (simple trial division) - ok for small numbers    static boolean isPrime(long n) {        if (n <= 1) return false;        if (n <= 3) return true;        if (n % 2 == 0) return false;        long r = (long) Math.sqrt(n);        for (long i = 3; i <= r; i += 2) {            if (n % i == 0) return false;        }        return true;    }    // Compute gcd    static long gcd(long a, long b) {        while (b != 0) {            long t = b;            b = a % b;            a = t;        }        return Math.abs(a);    }    // Extended Euclidean algorithm to find x,y such that a*x + b*y = gcd(a,b)    static long[] extendedGcd(long a, long b) {        if (a == 0) return new long[]{b, 0, 1};        long[] vals = extendedGcd(b % a, a);        long g = vals[0];        long x1 = vals[1];        long y1 = vals[2];        long x = y1 - (b / a) * x1;        long y = x1;        return new long[]{g, x, y};    }    // Modular inverse of a mod m (assumes gcd(a,m)==1)    static long modInverse(long a, long m) {        long[] vals = extendedGcd(a, m);        long g = vals[0];        long x = vals[1];        if (g != 1) throw new ArithmeticException("Inverse doesn't exist");        long res = x % m;        if (res < 0) res += m;        return res;    }    // Fast modular exponentiation (base^exp) % mod    static long modExp(long base, long exp, long mod) {        base = ((base % mod) + mod) % mod;        long result = 1 % mod;        while (exp > 0) {            if ((exp & 1L) == 1L) {                result = (multiplyMod(result, base, mod)) % mod;            }            base = (multiplyMod(base, base, mod)) % mod;            exp >>= 1;        }        return result;    }    // Safe modular multiplication    static long multiplyMod(long a, long b, long mod) {        a = ((a % mod) + mod) % mod;        b = ((b % mod) + mod) % mod;        long result = 0;        while (b > 0) {            if ((b & 1L) == 1L) {                result = (result + a) % mod;            }            a = (a << 1) % mod;            b >>= 1;        }        return result;    }    // Find a random e coprime with phi    static long findCoprime(long phi) {        long e;        do {            e = 2 + Math.abs(rnd.nextLong()) % (phi - 2);            if (e < 2) e = 2;        } while (gcd(e, phi) != 1);        return e;    }    // SHA-256 hex of input string    static String sha256Hex(String input) throws Exception {        MessageDigest md = MessageDigest.getInstance("SHA-256");        byte[] d = md.digest(input.getBytes("UTF-8"));        StringBuilder sb = new StringBuilder();        for (byte b : d) sb.append(String.format("%02x", b & 0xff));        return sb.toString();    }    // ---------- RSA operations ----------    static long[] rsaEncryptString(String message, long e, long n) {        char[] chars = message.toCharArray();        long[] cipher = new long[chars.length];        for (int i = 0; i < chars.length; i++) {            long m = (long) chars[i];            if (m >= n) throw new IllegalArgumentException("Character code >= n. Choose larger primes.");            cipher[i] = modExp(m, e, n);        }        return cipher;    }    static String rsaDecryptToString(long[] cipher, long d, long n) {        StringBuilder sb = new StringBuilder();        for (long c : cipher) {            long m = modExp(c, d, n);            sb.append((char) m);        }        return sb.toString();    }    static long[] generateSignature(String message, long d, long n) throws Exception {        String hex = sha256Hex(message);        return rsaEncryptString(hex, d, n); // sign using private key    }    static boolean verifySignature(String message, long[] signature, long e, long n) throws Exception {        String recoveredHex = rsaDecryptToString(signature, e, n);        String expectedHex = sha256Hex(message);        return expectedHex.equalsIgnoreCase(recoveredHex);    }    static String longArrayToString(long[] arr) {        StringBuilder sb = new StringBuilder();        sb.append("[");        for (int i = 0; i < arr.length; i++) {            sb.append(arr[i]);            if (i < arr.length - 1) sb.append(", ");        }        sb.append("]");        return sb.toString();    }    // ---------- Main ----------    public static void main(String[] args) throws Exception {        Scanner sc = new Scanner(System.in);        System.out.println("=== RSA + Digital Signature Demo ===");        System.out.println("IMPORTANT: Use small primes so that (p*q) fits in 'long' and character codes < n.\n");        System.out.print("Enter prime p: ");        long p = sc.nextLong();        System.out.print("Enter prime q: ");        long q = sc.nextLong();        if (!isPrime(p) || !isPrime(q)) {            System.out.println("ERROR: Both p and q must be prime. Exiting.");            sc.close();            return;        }        if (p == q) {            System.out.println("ERROR: p and q should be distinct. Exiting.");            sc.close();            return;        }        long n = p * q;        long phi = (p - 1) * (q - 1);        long e = findCoprime(phi);        long d = modInverse(e, phi);        System.out.println("\nGenerated keys:");        System.out.println("p = " + p + ", q = " + q);        System.out.println("n = p*q = " + n);        System.out.println("phi(n) = " + phi);        System.out.println("Public key (e, n): (" + e + ", " + n + ")");        System.out.println("Private key (d, n): (" + d + ", " + n + ")\n");        // Receiver Y key generation        System.out.println("Now enter primes for Receiver Y:");        System.out.print("Enter prime p2: ");        long p2 = sc.nextLong();        System.out.print("Enter prime q2: ");        long q2 = sc.nextLong();        if (!isPrime(p2) || !isPrime(q2) || p2 == q2) {            System.out.println("ERROR: Invalid primes for receiver. Exiting.");            sc.close();            return;        }        long n2 = p2 * q2;        long phi2 = (p2 - 1) * (q2 - 1);        long e2 = findCoprime(phi2);        long d2 = modInverse(e2, phi2);        System.out.println("\nReceiver Y public (e, n): (" + e2 + ", " + n2 + ")");        System.out.println("Receiver Y private (d, n): (" + d2 + ", " + n2 + ")\n");        sc.nextLine(); // consume newline        System.out.print("Enter message that X will send to Y: ");        String message = sc.nextLine();        long[] encrypted = rsaEncryptString(message, e2, n2);        System.out.println("\nEncrypted message: " + longArrayToString(encrypted));        long[] signature = generateSignature(message, d, n);        System.out.println("Signature: " + longArrayToString(signature));        // Attacker demo        System.out.println("\nAttacker Z tries to decrypt using wrong key (demonstration).");        try {            long bogusD = 12345L;            String zReads = rsaDecryptToString(encrypted, bogusD, n2);            System.out.println("Z reads (unexpected): " + zReads);        } catch (Exception ex) {            System.out.println("Z failed to read the message (as expected). Exception: " + ex.getMessage());        }        String decrypted = rsaDecryptToString(encrypted, d2, n2);        System.out.println("\nReceiver Y decrypts and gets: " + decrypted);        boolean valid = verifySignature(decrypted, signature, e, n);        System.out.println("Signature verification result: " + (valid ? "VALID" : "INVALID"));        if (valid)            System.out.println("Message integrity & authenticity verified. Sender X cannot repudiate.");        else            System.out.println("Signature invalid — message integrity/authenticity failed.");        sc.close();    }}Assignment 7<!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8" />  <meta name="viewport" content="width=device-width, initial-scale=1.0" />  <title>Secure Login | SHA-256 + Email Salt + Attempt Limit</title>  <!-- <style>    body {      font-family: 'Poppins', sans-serif;      background: linear-gradient(135deg, #0b172a, #1b2735);      color: #f2f4f8;      display: flex;      justify-content: center;      align-items: center;      height: 100vh;    }    .container {      background: #1d2a3a;      padding: 2rem 3rem;      border-radius: 12px;      box-shadow: 0 0 20px rgba(0,0,0,0.3);      width: 340px;      text-align: center;    }    input {      width: 90%;      padding: 10px;      margin: 8px 0;      border: none;      border-radius: 6px;      background: #2c3e50;      color: white;    }    button {      margin: 8px;      padding: 10px 20px;      border: none;      background: #00b3ff;      color: white;      border-radius: 6px;      cursor: pointer;      font-weight: bold;    }    button:hover {      background: #0099e0;    }    .hash {      font-size: 0.8rem;      color: #bfcbd8;      word-break: break-all;    }  </style> --></head><body>  <div class="container">    <h2>Secure Login System</h2>    <p>Using SHA-256 + Email Salt + Login Attempt Limit</p>    <input type="email" id="email" placeholder="Enter Email" /><br />    <input type="password" id="password" placeholder="Enter Password" /><br />    <button onclick="register()">Register</button>    <button onclick="login()">Login</button>    <p id="message"></p>    <p class="hash" id="hashOutput"></p>  </div>  <script>    // Function to compute SHA-256 hash using Web Crypto API    async function sha256(message) {      const encoder = new TextEncoder();      const data = encoder.encode(message);      const hashBuffer = await crypto.subtle.digest("SHA-256", data);      const hashArray = Array.from(new Uint8Array(hashBuffer));      return hashArray.map(b => b.toString(16).padStart(2, "0")).join("");    }    // Function to register user (store hashed password)    async function register() {      const email = document.getElementById("email").value.trim();      const password = document.getElementById("password").value;      if (!email || !password) {        document.getElementById("message").innerText = "Please enter email and password!";        return;      }      const saltedInput = password + email;      const hash = await sha256(saltedInput);      localStorage.setItem(email, hash);      localStorage.setItem(email + "_attempts", "0");       document.getElementById("message").innerText = "User registered securely!";      document.getElementById("hashOutput").innerText = "Stored hash: " + hash+" Salt with Email";    }    // Function to handle login with attempt tracking    async function login() {      const email = document.getElementById("email").value.trim();      const password = document.getElementById("password").value;      const storedHash = localStorage.getItem(email);      if (!storedHash) {        document.getElementById("message").innerText = "User not found!";        return;      }      let attempts = parseInt(localStorage.getItem(email + "_attempts")) || 0;      const MAX_ATTEMPTS = 3;      // Check if account is locked      if (attempts >= MAX_ATTEMPTS) {        document.getElementById("message").innerText = "Login limit exceeded! Account locked.";        document.getElementById("hashOutput").innerText = "";        return;      }      const saltedInput = password + email;      const hash = await sha256(saltedInput);      if (hash === storedHash) {        document.getElementById("message").innerText = "Login successful! Password verified securely.";        document.getElementById("hashOutput").innerText = "Matching hash: " + hash;        // Reset attempts after successful login        localStorage.setItem(email + "_attempts", "0");      } else {        attempts++;        localStorage.setItem(email + "_attempts", attempts.toString());         if (attempts >= MAX_ATTEMPTS) {          document.getElementById("message").innerText = "Login limit exceeded! Account locked.";        } else {          document.getElementById("message").innerText =            `Invalid password! (${MAX_ATTEMPTS - attempts} attempt(s) left)`;        }        document.getElementById("hashOutput").innerText = "";      }    }  </script></body></html>Assignment 8import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.security.SecureRandom;import java.util.Scanner;public class Assignment8 {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        System.out.print("Enter image filename to encrypt/decrypt: ");        String inputFile = sc.nextLine();        System.out.print("Enter output filename: ");        String outputFile = sc.nextLine();        System.out.print("Enter secret key (string): ");        String key = sc.nextLine();        sc.close();        try {            FileInputStream fis = new FileInputStream(inputFile);            FileOutputStream fos = new FileOutputStream(outputFile);            int data;            SecureRandom secureRand = SecureRandom.getInstance("SHA1PRNG");            secureRand.setSeed(key.getBytes());              while ((data = fis.read()) != -1) {                int randomByte = secureRand.nextInt(256);                fos.write(data ^ randomByte);             }            fis.close();            fos.close();            System.out.println("\n Process completed successfully!");            System.out.println("Output file: " + outputFile);            System.out.println("(Run again with the same key to decrypt the image)");        } catch (IOException e) {            System.out.println("Error: " + e.getMessage());        } catch (Exception e) {            System.out.println("SecureRandom error: " + e.getMessage());        }    }}